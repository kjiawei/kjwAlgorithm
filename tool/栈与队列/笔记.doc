
=================
    所有的内核链表的操作函数都是对小结构体进行操作的，不要错误理解成大结构体
      (3)内核链表的遍历：
             方法一：list_for_each()跟list_entry()相互配合实现遍历
             方法二：list_for_each_entry(pos, head, member) 将方法一的二个宏函数合并了
                       pos ---》大结构体指针
                       head ---》小结构体指针
                       member ---》小结构体在大结构体中的名字
                    注意：第一个参数一定不要传参错误，是大结构体
             方法三：list_for_each_entry_safe(pos, n, head, member)  往往在删除节点的时候使用
                       pos ---》大结构体指针
                       n ---》大结构体指针
                       head ---》小结构体指针
                       member ---》小结构体在大结构体中的名字
      （4）删除
             list_for_each_entry_safe(pos, n, head, member)
             list_del(struct list_head *entry)
                    entry ---》你想要删除的那个节点里面的小结构体指针 
      （5）list_move(struct list_head *list,
struct list_head *head)
             list_move（） ---》将指定的节点移动到head的下一个位置
             list_move_tail（）---》将指定的节点移动到最后面
      （6）container_of(ptr, type, member) 求ptr对应的大结构体 
虽然内核链表没有给我们封装指定位置插入的函数，但是你可以自己去写，注意使用的指针是小结构体里面的next和prev
       总结：(1)经过反复使用内核链表，加上分析了源码，我们发现内核链表跟前面学的双向循环链表的操作模式是类似的，只是要注意内核链表是操作的小结构体指针，所有在指针的写法上变得很嗦（自己体会，查看我写的最终代码）
             (2)内核链表中封装的那个小结构体一般都写成普通结构体，注意在使用的时候取地址 
  
 


==============栈和队列===========
1.栈：先进后出   特殊的数据结构
2.如何实现栈这种操作呢？？
     说白了就是人为地通过代码实现先进后出
     （1）用顺序表来实现栈的操作---》顺序栈
           struct stack
           {
                 int a[20];
                 int top;
           };
           压栈（必须保证从栈顶的位置）push
           出栈（必须保证从栈顶的位置）pop
     （2）用链表实现栈 ---》链式栈   换汤不换药   单链表去实现
           struct stack_list
           {
                 int data;
                 struct stack_list *next
           };

3.队列：特点先进先出  
      （1）用顺序表实现队列操作--》 出队   入队
            struct sququ
           {
                 int a[20];
                 int front;  // 表示队头的位置
                 int rear;  // 表示队尾的位置
           };   
      （2）用链表实现队列 ---》链式队列

作业：1.实现将一个整数，转换成指定的进制  2   8   16
int scale_convert(int num,int scale)
{


}

      2.队列实现
      3.二叉树的前中后



====================树===========================
1.基本概念
    根：相对的概念，只要有分叉的都是根---》根节点（父节点）
                           分下去的杈---》叶子节点（孩子节点）
    二叉树：确保每个根节点分下去树杈不可以超过两个
    满二叉树：
    左孩子和右孩子
    树的深度：树有多少层
    满二叉树的节点个数n跟深度h之间的关系是：  n=2^h-1
2.二叉树的遍历
    前序，中序，后序，按层
      前序：根---》左---》右
          最开始的根一定是最顶层的那个根节点
          
      中序：左---》根---》右
          最开始的左是图中最底层，最左边的那个左孩子
      后序：左---》右---》根
      按层：从上到下，从左到右
  总结：规则很明确，但是结合具体的二叉树去分析的时候，注意：每个节点有多重身份（根，左，右）--->你在套用这些规则的时候，你必须递归地去套用一次口诀
  

    











      